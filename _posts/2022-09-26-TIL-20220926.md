---
title: "20220926 React 공부"
excerpt: "React 공부"

categories:
  - TIL
tags:
  - [TIL, React]

permalink: /TIL/20220926/

toc: true
toc_sticky: true

date: 2022-09-26
last_modified_at: 2022-09-26
---

## [React] 리액트를 다루는 기술

### 4장 이벤트 핸들링
JSBin(https://jsbin.com/) : 코드 테스트 사이트

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>JS Bin</title>
</head>
<body>
  <button onclick = "alert('executed')">
    Click Me
   </button>
</body>
</html>
```
```javascript
import {useState} from 'react';

const Say = () => {
  const [message, setMessage] = useState('');
  const onClickEnter = () => setMessage('안녕하세요!');
  const onClickLeave = () => setMessage('안녕히 가세요!');
  
  const [color, setColor] = useState('black');
  
  return (
    <div>
      <button onClick = {onClickEnter}>입장</button>
      <button onClick = {onClickLeave}>퇴장</button>
      <h1>{message}</h1>
     </div>
  );
};

export default Say;
```

#### 이벤트를 사용할 때 주의 사항
1. 이벤트 이름은 카멜 표기법으로 작성한다. ie. onkeyup -> onKeyUp <br/>
>❓왜 카멜 표기법.<br/>
소문자 html 태그

2. 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달한다. <br/>
(html) 이벤트 설정 시 큰따옴표 안에 실행할 코드를 넣음. (ie. <button onclick = "alert('executed')">) <br/>
(react) 함수 형태의 객체를 전달함. (ie. <button onClick = {onClickEnter}>) <br/>
  a. 함수를 랜더링을 하는 동시에 바로 만들어 전달. <br/>
  b. 함수를 렌더링 외부에 미리 만들어 전달. <br/>
  
3. DOM 요소에만 이벤트를 설정할 수 있다. <br/>
div, button, input, form, span등의 DOM 요소에는 이벤트를 설정할 수 있지만, 우리가 직접 만든 컴포넌트에는 이벤트를 자체적으로 설정할 수 없다. <br/>
  ex) <MyComponent onClick = {doSomething}/> 에서, <br/>
  > MyComponent를 클릭할 때 domSomething 함수를 실행하는 것이 아니라, 그냥 이름이 onClick인 props를 MyComponent에게 전달해 줄 뿐임.❓ <br/>
  
  따라서 컴포넌트에 자체적으로 이벤트를 설정할 수 없다. 하지만 전달받은 props에 컴포넌트 내부의 DOM 이벤트로 설정할 수는 있다. ie. <div onClick = {this.props.onClick}> <br/>
  
  
#### 리액트에서 지원하는 이벤트 종류
- Clipboard
- Touch
- Composition
- UI
- KeyBoard
- Wheel
- Focus
- Media
- Form
- Image
- Mouse
- Animation
- Selection
- Transition
- etc. 리액트 매뉴얼(https://facebook.github.io/react/docs/events.html)
  

#### 예제로 이벤트 핸들링 익히기 - 클래스형 컴포넌트

##### 컴포넌트 생성
EventPractice.js - 클래스형 컴포넌트 생성
  ```javascript
  import {Component} from 'react';
  
  class EventPractice extends Component {
    render() {
      return (
        <div>
          <h1>이벤트 연습</h1>
        </div>
      );
    }
  }
  
  export default EventPractice;
  ```
  
##### App.js에서 생성한 컴포넌트 렌더링
  ```javascript
  import EventPractice from './EventPractice';
  
  const App = () => {
    return <EventPractice />;
  };
  
  export default App;
  ```
  
##### 이벤트 핸들링
  EventPractice.js - EventPractice 컴포넌트에 input 요소 렌더링, input 요소에 onChange 이벤트 설정.
  ```javascript
  import {Component} from 'react';
  
  class EventPractice extends Component {
    render() {
      return (
        <div>
          <h1>이벤트 연습</h1>
          <input
                 type = "text"
                 name = "message"
                 placeholder = "아무거나 입력해 보세요"
                 onChange = {
                   (e) => {
                      console.log(e);
                   }
                 }
          />
        </div>
      );
    }
  }
  
  export default EventPractice;
  ```
  >콘솔에 기록되는 e 객체 : SyntheticEvent. 웹 브라우저의 네이티브 이벤트를 감싸는 객체.❓ <br/>
  DOM Element의 경우 핸들링 함수에 event=e object를 매개변수로 전달한다. event object를 이용하여 이벤트 발생 원인, 이벤트가 일어난 Element에 대한 정보를 얻을 수 있다.
이벤트 형태(클릭, 키 입력 등)와 DOM 종류(button, form, input 등)에 따라 전달되는 이벤트 object의 내용도 다르니 유의할 것. <br/>

  >네이티브 이벤트와 인터페이스가 같으므로 순수 자바스크립트에서 html 이벤트를 다룰 때와 똑같이 사용하면 됨.❓
  
  ###### SyntheticEvent
  
  이벤트가 끝나고 나면 이벤트 초기화 됨. <br/>
  >❓왜 이벤트가 초기화 되는 것일까? <br/>
    리액트에서 사용되고 있는 SyntheticEvent는 객체 풀링 방식을 사용한다.(Object Pooling) 매 이벤트마다 해당 객체 사용되는것에 대해서 성능상의 이유로 리액트 에서는 객체 풀링 방식을 사용함으로써 객체 생성 시간을 줄이고 GC(가비지콜렉터)에 대한 노출도 줄이며 메모리관리에 소비되는 시간을 줄이는 방식을 사용하고 있기 때문이다. 그렇기 때문에 객체가 호출되고 난 후에 이벤트 속성이 초기화된다. <br/>
  
  비동기적 이벤트 객체 참조를 원한다면 e.persist() 함수 호출해야. <br/>
  >❓비동기적  <br/>
  동기(sync)는 우리가 통상 알고있는 코드가 위에서 밑으로 내려 읽으면서 순차적으로 코드가 적용됨. 
  비동기(async)는 setTimeout처럼 독자적으로 비동기적으로 발동하거나 ajax 호출의 많은양의 데이터를 가져올때 비동기적으로 가져와서 화면상에 실질적으로 멈춰보이는듯한 증상을 제거할 수 있음
  
  >❓콜백함수 = 이벤트함수
  콜백함수를 사용하는 이유는 비동기적 프로그래밍을 할 수 있기 때문.
  
  >비동기적 테크닉을 사용하는 이유 <br/>
  1.사용자 이벤트 처리 <br/>
브라우저 화면에서 발생하는 사용자의 이벤트는 예측이 불가능하다.
따라서 이런 화면이벤트를 관리담당하는 녀석에게 우리는 특정이벤트가 발생할 때 호출을 원하는 내용을 callback 함수에 전달하게 된다. <br/>
2.네트워크 응답 처리 <br/>
화면단에서 서버에게 요청을 보냈을 때, 그 응답이 언제 올지 알 수 없다.
따라서 이런 서버에 대한 응답처리 등도 비동기적으로 처리해야 한다. <br/>
3.파일을 읽고 쓰는 등의 파일 시스템 작업 <br/>
4.의도적으로 시간 지연을 사용하는 기능(알람 등) <br/>
위와 같이 이벤트 등을 기다리는데 하나뿐인 소중한 스레드를 사용한다면, 또 서버의 응답을 기다리기 위해 하나뿐인 소중한 스레드를 사용한다면…
사용자는 멈춰져 있는 화면을 보게되는 것이다.
위와 같이 스레드의 블록킹을 야기하는 작업은 필수적으로 비동기적 프로그래밍을 해야 한다. <br/>
  
  >❓e.persist()  <br/>
  
  EventPractice.js - onChange 코드 수정
  ```javascript
  onChange = {
    (e) => {
      console.log(e.target.value);
    }
  }
  ```
  수정 후에는 값이 바뀔 때마다 바뀌는 값을 콘솔에 기록함. <br/>
  >❓e.persist()와 e.target.value의 관계 <br/>
  
  >❓e.target.value란? <br/>
  event=e object의 target은 이벤트의 원인이 되는 Element를 가리킨다.
현재 event의 target은 input element이므로 입력된 value를 가져와 콘솔에 출력하는 모습이다.
  
##### state에 input 값 담기

EventPractice.js - constructor에서 state 초깃값 설정, 이벤트 핸들링 함수 내부에서 this.setState 메서드 호출하여 state 업데이트, input의 value 값을 state에 있는 값으로 설정.
  ```javascript
  import {Component} from 'react';
  
  class EventPractice extends Component {
  
    state = {
      message: ''
    }
  
    render() {
      return (
        <div>
          <h1>이벤트 연습</h1>
          <input
                 type = "text"
                 name = "message"
                 placeholder = "아무거나 입력해 보세요"
                 value = {this.state.message}
                 onChange = {
                   (e) => {
                      this.setState({
                        message: e.target.value
                      })
                   }
                 }
          />
        </div>
      );
    }
  }
  
  export defalut EventPractice;
  ```
  >❓input의 value 값으로 state 값을 넣어주는 건 어디에 쓰일까. value 값을 비워두면 어떻게 될까.
  
##### 버튼을 누를 때 comment 값을 공백으로 설정

EventPractice.js - button을 만들고 클릭 이벤트가 발생하면 현재 comment 값을 메시지 박스로 띄운 후 comment 값을 공백으로 설정. (for 입력한 값이 state에 잘 들어갔고 인풋에서 그 값을 제대로 반영하는지 검증.)
  ```javascript
  import {Component} from 'react';
  
  class EventPractice extends Component {
  
    state = {
      message: ''
    }
  
    render() {
      return (
        <div>
          <h1>이벤트 연습</h1>
          <input
                 type = "text"
                 name = "message"
                 placeholder = "아무거나 입력해 보세요"
                 value = {this.state.message}
                 onChange = {
                   (e) => {
                      this.setState({
                        message: e.target.value
                      })
                   }
                 }
          />
          <button onClick = {
            () => {
              alert(this.state.message);
              this.setState({
                message: ''  
              });
            }
          }>확인</button>
        </div>
      );
    }
  }
  
  export defalut EventPractice;
  ```
> ❓갑자기 comment는 뭘까. 
  comment는 그냥 입력한 값 의미.
  
##### 임의 메서드 만들기

리액트에서는 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니라, 함수 형태의 값을 전달하는 것이고 <br/>
  a. 함수를 랜더링을 하는 동시에 바로 만들어 전달. ie. onChange = {
                                                       (e) => {
                                                          this.setState({
                                                            message: e.target.value
                                                          })
                                                       }
                                                     } <br/>
  b. 함수를 렌더링 외부에 미리 만들어 전달. ie. handleChange(e) {
                                                this.setState({
                                                  message: e.target.value
                                                });
                                              }
                                              onChange = {this.handleChange} <br/>
이렇게 두가지 방식이 있을 수 있는데 앞서 첫번째 방식을 본것이고 이제 두번째 방식을 살펴보자. <br/>
EventPractice.js - onChange와 onClick에 전달한 함수를 따로 빼내서 컴포넌트 임의 메서드를 만들어 보자
  ```javascript
  import {Component} from 'react';
  
  class EventPractice extends Component {
  
    state = {
      message: ''
    }
  
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.handleClick = this.handleClick.bind(this);
    }
  
    handleChange(e) {
      this.setState({
        message: e.target.value
      });
    }
  
    handleClick() {
      alert(this.state.message);
      this.setState({
        message: ''
      });
    }
  
    render() {
      return (
        <div>
          <h1>이벤트 연습</h1>
          <input
                 type = "text"
                 name = "message"
                 placeholder = "아무거나 입력해 보세요"
                 value = {this.state.message}
                 onChange = {this.handleChange}
          />
          <button onClick = {this.handleClick}>확인</button>
        </div>
      );
    }
  }
  
  export defalut EventPractice;
  ```
  
  함수가 호출될 때 this는 호출부에 따라 결정되므로, 클래스의 임의 메서드가 특정 HTML 요소의 이벤트로 등록되는 과정에서 메서드와 this의 관계가 끊어져 버린다. 이 때문에 임의 메서드가 이벤트로 등록되어도 this를 컴포넌트 자신으로 제대로 가리키기 위해서는 메서드를 this와 바인딩하는 작업이 필요하다. 만약 바인딩하지 않는 경우라면 this가 undefined를 가리키게 된다. 따라서 정석으로는 생성자 메서드에서 
constructor(props) {
  super(props);
  this.handleChange = this.handleChange.bind(this);
  this.handleClick = this.handleClick.bind(this);
}
이렇게 메서드 바인딩을 해준다.
  
##### Property Initializer Sysntax를 사용한 메서드 작성
  
  앞서 말했듯이 메서드 바인딩은 생성자 메서드에서 하는 것이 정석이지만 새 메서드를 만들때마다 생성자도 수정해야 하기 때문에 불편할 수 있음. 더 간단하게 하는 방법은 바벨의 transform-class-properties 문법을 사용해 화살표 함수 형태로 메서드를 정의하는 것.
  EventPractice.js - transform-class-properties 문법 사용해 화살표 함수 형태로 메서드 정의
  ```javascript
  import {Component} from 'react';
  
  class EventPractice extends Component {
  
    state = {
      message: ''
    }
  
    handleChange = (e) => {
      this.setState({
        message: e.target.value
      });
    }
  
    handleClick = () => {
      alert(this.state.message);
      this.setState({
        message: ''
      });
    }
  
    render() {
      return (
        <div>
          <h1>이벤트 연습</h1>
          <input
                 type = "text"
                 name = "message"
                 placeholder = "아무거나 입력해 보세요"
                 value = {this.state.message}
                 onChange = {this.handleChange}
          />
          <button onClick = {this.handleClick}>확인</button>
        </div>
      );
    }
  }
  
  export defalut EventPractice;
  ```
  이게 화살표 함수를 쓰는 이유인가. 화살표함수와 기본함수의 차이에 this와 관련된게 있었는데 화살표함수는 이렇게 this를 신경쓰지 않고 사용해도 돼서 더 간단하다는 거였나봄. <br />
  화살표 함수 형식 어렵게 생각할 필요 없이 보니까 handleChange(e) {} 이 형태에서 handleChange와 (e) 사이에 = 넣고, (e)와 {} 사이에 => 넣어주면 되는 거였음.
  
##### input 여러 개 다루기
  
EventPractice.js
  ```javascript
  import {Component} from 'react';
  
  class EventPractice extends Component {
  
    state = {
      username: '',
      message: ''
    }
  
    handleChange = (e) => {
      this.setState({
        [e.target.name]: e.target.value
      });
    }
  
    handleClick = () => {
      alert(this.state.username + ': ' + this.state.message);
      this.setState({
        username: '',
        message: ''
      });
    }
  
    render() {
      return (
        <div>
          <h1>이벤트 연습</h1>
          <input
                 type = "text"
                 name = "username"
                 placeholder = "사용자명"
                 value = {this.state.username}
                 onChange = {this.handleChange}
          />
          <input
                 type = "text"
                 name = "message"
                 placeholder = "아무거나 입력해 보세요"
                 value = {this.state.message}
                 onChange = {this.handleChange}
          />
          <button onClick = {this.handleClick}>확인</button>
        </div>
      );
    }
  }
  
  export defalut EventPractice;
  ```
  handleChange 함수에서 객체 안 key를 []로 감싼것이 핵심인데, 이렇게 되면 그 안에 넣은 레퍼런스가 가리키는 실제 값이 key 값으로 사용된다. <br/>
    ie. const name = 'varianKey'; <br/>
        const object = { <br/>
          [name] : 'value' <br/>
        }; <br/>
        일때, 결과는 'varianKey' : 'value' 인것이다. <br/>
따라서 handleChange 함수에서 첫번째 인풋이 입력될때는 name이 username으로 정해져있으니까 ([e.target.name] =) e.target.username값으로 입력되고 있는 값(e.target.value)이 들어가고 두번째 인풋이 입력될때는 name이 message로 정해져있으니까 ([e.target.name] =) e.target.message값으로 입력되고 있는 값(e.target.value)가 들어간다.  <br/> 
  
##### onKeyPress 이벤트 핸들링
  
EventPractice.js - 두번째 텍스트 인풋에서 텍스트 입력하고 enter키를 눌렀을 때 handleClick 메서드 호출
  ```javascript
  import {Component} from 'react';
  
  class EventPractice extends Component {
  
    state = {
      username: '',
      message: ''
    }
  
    handleChange = (e) => {
      this.setState({
        [e.target.name]: e.target.value
      });
    }
  
    handleClick = () => {
      alert(this.state.username + ': ' + this.state.message);
      this.setState({
        username: '',
        message: ''
      });
    }
  
    handleKeyPress = (e) => {
      if(e.key == 'Enter') {
        this.handleClick();
      }
    }
  
    render() {
      return (
        <div>
          <h1>이벤트 연습</h1>
          <input
                 type = "text"
                 name = "username"
                 placeholder = "사용자명"
                 value = {this.state.username}
                 onChange = {this.handleChange}
          />
          <input
                 type = "text"
                 name = "message"
                 placeholder = "아무거나 입력해 보세요"
                 value = {this.state.message}
                 onChange = {this.handleChange}
                 onKeyPress = {this.handleKeyPress}
          />
          <button onClick = {this.handleClick}>확인</button>
        </div>
      );
    }
  }
  
  export defalut EventPractice;
  ```
  
#### 예제로 이벤트 핸들링 익히기 - 함수형 컴포넌트
  
EventPractice.js - 함수형 컴포넌트
  ```javascript
  import {useState} from 'react';
  
  const EventPractice = () => {
  
    const [username, setUsername] = useState('');
    const [message, setMessage] = useState('');
    const onChangeUsername = e => setUsername(e.target.value);
    const onChangeMessage = e => setMessage(e.target.value);
    const onClick = () => {
      alert(userName + ': ' + message);
      setUsername('');
      setMessage('');
    };
  
    const onKeyPress = e => {
      if (e.key === 'Enter') {
        onClick();
      }
    };
  
    return (
      <div>
        <h1>이벤트 연습</h1>
        <input
               type = "text"
               name = "username"
               placeholder = "사용자명"
               value = {username}
               onChange = {onChangeUsername}
        />
        <input
               type = "text"
               name = "message"
               placeholder = "아무거나 입력해 보세요"
               value = {message}
               onChange = {onChangeMessage}
               onKeyPress = {onKeyPress}
        />
        <button onClick = {onClick}>확인</button>
      </div>
    );
  };
  
  export defalut EventPractice;
  ```
여기서도 e.target.name 활용해도 되지만 이번에는 onChange 관련 함수 두개를 따로 만들어줬음. <br/>

##### useState에서 form 객체 사용
  
for 여러 개의 인풋 상태를 관리하기 위해 <br/>
EventPractice.js - useState를 통해 사용하는 상태에 문자열이 아닌 form 객체 넣어보자
  ```javascript
  import {useState} from 'react';
  
  const EventPractice = () => {
  
    const [form, setForm] = useState({
      username: '',
      message: ''
    });
  
    const {username, message} = form;
  
    const onChange = e => {
      const nextForm = {
        ...form, // 기존의 form 내용을 이 자리에 복사한 뒤
        [e.target.name]: e.target.value // 원하는 값을 덮어 씌우기
      };
      setForm(nextForm);
    };
 
    const onClick = () => {
      alert(userName + ': ' + message);
      setForm({
        username: '',
        message: ''
      });
    };
  
    const onKeyPress = e => {
      if (e.key === 'Enter') {
        onClick();
      }
    };
  
    return (
      <div>
        <h1>이벤트 연습</h1>
        <input
               type = "text"
               name = "username"
               placeholder = "사용자명"
               value = {username}
               onChange = {onChange}
        />
        <input
               type = "text"
               name = "message"
               placeholder = "아무거나 입력해 보세요"
               value = {message}
               onChange = {onChange}
               onKeyPress = {onKeyPress}
        />
        <button onClick = {onClick}>확인</button>
      </div>
    );
  };
  
  export defalut EventPractice;
  ```
  e.target.name 값을 활용하려면 useState를 쓸 때 인풋 값들이 들어 있는 form 객체를 사용해주면 됨.
  
