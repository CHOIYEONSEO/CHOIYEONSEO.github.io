---
title: "20220919 우테코 프리코스 3주차 피드백, 4주차 체크리스트"
excerpt: "[우테코 프리코스] 3주차 과제 공통 피드백 & 4주차 과제 체크리스트"

categories:
  - TIL
tags:
  - [TIL]

permalink: /TIL/20241105/

toc: true
toc_sticky: true

date: 2024-11-05
last_modified_at: 2024-11-05
---

<a href="https://github.com/woowacourse-precourse/javascript-lotto-7/pull/328" target="_blank">우테코 프리코스 3주차 과제</a>를 제출했다.<br>
이제 벌써 마지막 과제다.

# 우테코 프리코스 3주차 과제 공통 피드백
학습 목표 : 클래스 분리, 단위 테스트 시작<br>
이 학습목표는 4주차까지 이어지기 때문에 아직 어렵더라도 너무 걱정하지 않아도 된다. 더 좋은 코드를 작성하는데 점진적으로 익숙해지는 과정이라고 생각하자.<br>
<span style="color:gray">▶ ✅ 나 좀 빠른걸지도? ㅎㅎ </span><br><br>

## 함수(메서드) 라인에 대한 기준도 적용한다
프로그래밍 요구사항에는 함수의 길이를 15라인으로 제한하는 규칙이 포함되어 있다. 이 규칙은 main() 함수도 동일하게 적용되며, 공백 라인도 한 라인으로 간주한다. 
만약 함수가 15라인을 초과한다면, 역할을 더 명확하게 나누고, 코드의 가독성과 유지보수성을 높일 수 있는 신호로 인식하고 함수 분리 또는 클래스 분리를 고려해야 한다.<br>
<span style="color:gray">▶ ✅ 공백 라인도 한 라인으로 간주하는지는 몰랐는데 내 코드들이 15라인을 공백 포함 넘지 않았는지 다시 봐야겠다. 그리고 이번 과제는 10라인을 넘으면 안되는데 더 역할을 명확하게 나눌 수 있게 해야겠다. </span><br><br>

## 예외 상황에 대해 고민한다
정상적인 상황을 구현하는 것보다 예외 상황을 모두 고려하여 프로그래밍하는 것이 훨씬 어렵다. 하지만, 이러한 예외 상황을 처리하는 습관을 들이는 것이 중요하다. 코드를 작성할 때는 예상되는 예외를 미리 고려하여, 프로그램이 비정상적으로 종료되거나 잘못된 결과를 내지 않도록 한다.<br>
예를 들어, 로또 미션에서 고려할 수 있는 예외 상황은 다음과 같다.<br>
- 로또 구입 금액에 1000 이하의 숫자를 입력
- 당첨 번호에 중복된 숫자를 입력
- 당첨 번호에 1~45 범위를 벗어나는 숫자를 입력
- 당첨 번호와 중복된 보너스 번호를 입력
<span style="color:gray">▶ ✅ 전부 내가 고민하고 처리했던 예외 상황이다! 다른 점이 하나 있다면 로또 구입 금액에 나는 0을 입력하거나 1000원 단위가 아닌 값을 입력할 때 예외로 처리했는데 1000 이하의 숫자를 입력하지 못하도록 처리할 수도 있다는 것.</span><br><br>

## 비즈니스 로직과 UI 로직을 분리한다
비즈니스 로직과 UI 로직을 한 클래스에서 처리하는 것은 단일 책임 원칙(SRP)에 위배된다. 비즈니스 로직은 데이터 처리 및 도메인 규칙을 담당하고, UI 로직은 화면에 데이터를 표시하거나 입력을 받는 역할로 분리한다. 아래는 비즈니스 로직과 UI 로직이 혼재되어 있다.<br>
```javascript
class Lotto {
  #numbers

  // 로또 숫자가 포함되어 있는지 확인하는 비즈니스 로직
  contains(numbers) {
    ...
  }

  // UI 로직
  print() {
    ...
  }
}
```

비즈니스 로직은 그대로 유지하고, UI 관련 코드는 별도 View 클래스로 분리하는 것이 좋다. 현재 객체의 상태를 보기 위한 로그 메시지 성격이 강하다면, toString() 메서드를 통해 상태를 표현한다. 만약 UI에서 사용할 데이터가 필요하다면 getter 메서드를 통해 View 계층으로 데이터를 전달한다.<br>
<span style="color:gray">▶ ✅ 난 이번에 MVC 패턴을 적용해서 자연스럽게 비즈니스 로직과 UI 로직을 분리할 수 있었는데 단일 책임 원칙이라는 것이 있는지는 몰랐다. </span><br><br>

## 객체의 상태 접근을 제한한다
필드는 private class 필드로 구현한다. 객체의 상태를 외부에서 직접 접근하는 방식을 최소화 하는 이유에 대해서는 스스로 찾아본다.
```javascript
class WinningLotto {
  #lotto
  #bonusNumber

  constructor(lotto, bonusNumber) {
    this.#lotto = lotto
    this.#bonusNumber = bonusNumber
  }
}
```
<span style="color:gray">
▶ ✅ 비공개 필드(#)인 이름은 클래스안에서만 선언이 되어야 하고(ex. const banana = new Fruit('banana') (o), banana.#name = 'apple' (x)), 클래스 안에서만 접근 가능하고 클래스 밖에서는 접근이 불가능하다. 왜 private 필드로 구현해야 할까? <br>
클래스 내에서 데이터를 캡슐화하고, 외부에서 접근할 수 없도록 하는 것이 객체 지향 프로그래밍의 중요한 원칙 중 하나이기 때문이다. 프라이빗 필드는 위에서도 말했듯이 클래스 외부에서 접근할 수 없는 필드로 클래스 내부의 메서드를 통해서만 접근할 수 있다. 따라서 프라이빗 필드를 사용함으로써 클래스의 내부 상태를 보호하고 외부에서의 무분별한 접근을 막아 객체의 안정성을 높일 수 있다. <br>
나는 그럼 밖에 클래스에서는 해당 클래스의 값을 사용해야 할 때는 어떻게 해야하지?라고 생각했었는데, 클래스 내부에 getName() { return this.#name } 메서드를 만들고 외부에서는 이 getName() 메서드를 활용하면 되는 것 같다. <br><br>
  
결론 : 프라이빗 필드를 활용해서 클래스의 캡슐화를 강화하고 객체의 안정성을 높이도록 하자.
</span><br><br>

## 객체는 객체답게 사용한다
Lotto 클래스는 numbers를 상태 값으로 가지는 객체이다. 하지만 아래 객체는 로직 구현 없이 numbers에 대한 getter 메서드만을 제공하고 있다.<br>
```javascript
class Lotto {
  #numbers

  constructor(numbers) {
    this.#numbers = numbers
  }

  getNumbers() {
    return this.#numbers
  }
}


class LottoGame {
  play() {
    const lotto = new Lotto(...)

    // 숫자가 포함되어 있는지 확인한다.
    lotto.getNumbers().contains(number)  // bad

    // 당첨 번호와 몇 개가 일치하는지 확인한다.
    lotto.getNumbers().stream()...  // bad
  }
}
```
위의 코드처럼 ```Lotto```에서 데이터를 꺼내지(get) 말고 메시지를 던지도록 구조를 바꿔 데이터를 가지는 객체가 일하도록 한다. 이처럼 ```Lotto``` 객체에서 데이터를 꺼내(get) 사용하기보다는, 데이터가 가지고 있는 객체가 스스로 처리할 수 있도록 구조를 변경해야 한다. 아래와 같이 데이터를 외부에서 가져와(get) 처리하지 말고, 객체가 자신의 데이터를 스스로 처리하도록 메시지를 던지게 한다. <br>
```javascript
class Lotto {
  #numbers

  constructor(numbers) {
    this.#numbers = numbers
  }

  contains(number) {
    // 숫자가 포함되어 있는지 확인한다.
    return ...
  }

  matchCount(other) {
    // 당첨 번호와 몇 개가 일치하는지 확인한다.
    return ...
  }
}


class LottoGame {
  play() {
    const lotto = new Lotto(...)

    lotto.contains(number) // good
    lotto.matchCount(...) // good
  }
}
```
추가 참고 글 : <a href="https://tecoble.techcourse.co.kr/post/2020-04-28-ask-instead-of-getter/" target="_blank">getter를 사용하는 대신 객체에 메시지를 보내자</a><br>
<span style="color:gray">▶ ✅ 방금 위에서 get 메서드로 외부에서 클래스 프라이빗 필드 값 사용하면 되겠다 했는데 무분별하게 사용하면 안좋다고 한다.. 객체가 제대로 된 역할을 하도록 자신의 데이터는 자기가 처리하도록 하는 것이 좋다고 한다.</span><br><br>











피드백 강의 영상. 1주차에는 Java 언어 였지만 이번에는 자바스크립트 사용하는 강의다. 클래스의 역할과 테스트 검증 포인트에 초점을 맞추어 보면 도움이 될 것이다.
이번 영상은 TDD 방식으로 진행되어, TDD에 관심 있는 분들께 더 많은 도움이 될 것 같다. TDD가 처음이라면 미션에서 직접 도전해보는 것도 재미있는 경험이 될 것이다.









<mark>주황형광펜</mark>
<ins>밑줄</ins>
<br>
<br><br>
<span style="color:gray">▶ ✅ </span><br><br>
<span style="color:gray">▶ ❌ </span><br><br>
<span style="color:gray">▶ 🔺 </span><br><br>
<a href="" target="_blank"></a><br>
#FF6C02
