---
title: "20241127 이것이 코딩 테스트다 챕터6(정렬)"
excerpt: "정렬 알고리즘 - 선택 정렬/삽입 정렬/퀵 정렬"
categories:
  - TIL
tags:
  - [TIL, Algorithm]

permalink: /TIL/20241127/

toc: true
toc_sticky: true

date: 2024-11-27
last_modified_at: 2024-11-29
---

## 정렬 알고리즘
데이터를 특정한 기준에 따라서 순서대로 나열하는 것.<br>
정렬 알고리즘으로 데이터를 정렬하면 이진 탐색이 가능해짐. 즉, 정렬 알고리즘은 이진 탐색의 전처리 과정.<br>
정렬 알고리즘을 통해 '알고리즘의 효율성'을 이해할 수 있음.<br>

### 선택 정렬 (Selection Sort)
매번 '가장 작은 것'을 <ins>선택</ins>.<br>
데이터가 무작위로 여러 개 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 방식으로 정렬하는 것. <br>
가장 원시적인 방법.<br>
시간복잡도 데이터 개수 N일때, O(N^2).<br>
다른 정렬 알고리즘과 비교했을 때, 선택정렬은 O(N^2)의 시간복잡도를 가지기 때문에 매우 비효울적임. 하지만 특정한 리스트에서 가장 작은 데이터를 찾는 일이 코딩테스트에서 잦기 때문에 코드 형태에 익숙해질 필요가 있음.<br><br>

- 구현 방법

```python
array = [...]

for i in range(len(array)):                                #1
  min_index = i                                            #2
  for j in range(i+1, len(array)):                         #3
    if array[min_index] > array[j]:
      min_index = j                                        #3-1
  array[i], array[min_index[ = array[min_index], array[i]  #4
```
1. list의 길이동안 정렬되지 않은 데이터에 관해 2~4 반복
2. 정렬되지 않은 데이터 중 가장 왼쪽 데이터를 가장 작은 원소라 가정하고 해당 원소의 인덱스 ```min_index```로 저장
3. 정렬되지 않은 데이터 중 두번째 왼쪽 데이터부터 끝까지 min_index에 해당하는 원소와 크기 비교<br>
  3-1. 현재 min_index에 해당하는 원소보다 작은 원소가 있으면 해당 인덱스로 min_index 업데이트
4. 가장 왼쪽 데이터와 min_index에 해당하는 원소의 위치 스왑
<br><br>

> 파이썬에서 스왑은 ```array[0], array[1] = array[1], array[0]```로 간단히 가능.<br>
> 다른 언어에서는 임시 변수를 만들어 스왑해야 됨.

<br>

### 삽입 정렬 (Insertion Sort)
특정한 데이터를 '적절한 위치'에 <ins>삽입</ins>.<br>
데이터가 적절한 위치에 들어가기 전, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정하고 데이터를 하나씩 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에 그 위치에 삽입하는 방식으로 정렬하는 것. <br>
선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸지만 삽입 정렬은 그렇지 않음.<br>
즉, 필요할 때만 위치를 바꾸기 떄문에 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적임.<br>
시간복잡도 데이터 개수 N일때, O(N^2).<br>
하지만 **현재 리스트의 데이터가 거의 정렬되어 있는 경우**에는 어떤 정렬 알고리즘보다 **삽입 정렬 알고리즘이 가장 강력함**. 최선의 경우 O(N)의 시간 복잡도를 가짐.<br><br>

- 구현방법

```python
array = [...]

for i in range(1, len(arrar)):                     #1
  for j in range(i, 0, -1):                        #2
    if array[j] < array[j-1]:
      array[j], array[j-1] = array[j-1], array[j]  #2-1
    else:
      break                                        #2-2
```
1. list의 두번째 데이터부터 끝까지 정렬되지 않은 데이터에 관해 2~2-2 반복
2. 정렬되지 않은 데이터의 인덱스부터 인덱스 1까지 1씩 감소시키면서 현재 위치의 값과 하나 왼쪽 값 크기 비교<br>
  2-1. 왼쪽 값보다 현재 위치 값이 작으면 왼쪽 값이랑 현재 위치 값 스왑<br>
  2-2. 왼쪽 값이 더 작으면 그 위치에서 멈춤<br>

<br>

### 퀵 정렬
피벗이라는 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방식으로 빠르게 정렬하는 것.<br>
가장 많이 사용되는 알고리즘.<br><br> 

피벗을 설정하고 리스트를 분할하는 방법에 따라 퀵 정렬을 구분함.<br>

- 호어 분할 방식 : 리스트에서 첫 번째 데이터를 피벗으로 정함.

#### 호어 분할 방식


<hr>
